/**
 * types.ts
 * 
 * Type definitions for communication layer infrastructure.
 * Defines interfaces for message adapters, serializers, and queue management.
 */

import type { BaseMessage, TransportConfig } from '../../types/mission.types';

/**
 * QueuedMessage: Message awaiting transmission with retry metadata.
 * Used by BaseCommsAdapter's message queue to track delivery attempts.
 * 
 * Fields:
 * - id: Unique identifier (generated by BaseCommsAdapter)
 * - message: Original BaseMessage to send
 * - attempts: Number of send attempts so far (0-indexed)
 * - next_retry: Unix timestamp (ms) when next retry should occur
 * - created_at: Unix timestamp (ms) when message first queued
 */
export interface QueuedMessage {
  id: string;
  message: BaseMessage;
  attempts: number;
  next_retry: number;
  created_at: number;
}

/**
 * CommsAdapter: Abstract interface for hardware communication transports.
 * Implemented by TestCommsAdapter, SerialCommsAdapter, LoRaAdapter, etc.
 * Provides uniform API for sending/receiving messages regardless of
 * underlying transport mechanism (serial, radio, TCP, etc.).
 * 
 * Lifecycle:
 * 1. Create adapter: const adapter = CommsAdapterFactory.create(config);
 * 2. Initialize transport: await adapter.initialize();
 * 3. Register callbacks: adapter.onReceive((msg) => handleMessage(msg));
 * 4. Send messages: await adapter.send(message);
 * 5. Clean up: await adapter.close();
 */
export interface CommsAdapter {
  /**
   * Initialize transport connection (open serial port, connect socket, etc.).
   * Must be called before send() or onReceive(). Throws error if connection fails.
   */
  initialize(): Promise<void>;

  /**
   * Send message through transport with automatic retry logic.
   * Message queued immediately, Promise resolves when queued (not when delivered).
   * Actual delivery handled asynchronously by BaseCommsAdapter queue processor.
   */
  send(message: BaseMessage): Promise<void>;

  /**
   * Register callback to receive incoming messages.
   * Multiple callbacks can be registered; all invoked for each received message.
   * Errors in one callback don't stop other callbacks from executing.
   */
  onReceive(callback: (message: BaseMessage) => void): void;

  /**
   * Close transport connection gracefully.
   * Drains message queue (waits for pending sends), closes serial port/socket,
   * cancels retry timers. Safe to call multiple times (idempotent).
   */
  close(): Promise<void>;

  /**
   * Check if transport connection is currently active.
   * Returns true between successful initialize() and close() calls.
   * Does not ping hardware; purely checks local connection state.
   */
  isConnected(): boolean;

  /**
   * Get transport configuration (port, baud rate, protocol, etc.).
   * Useful for debugging, logging, or displaying connection status in UI.
   */
  getConfig(): TransportConfig;
}

/**
 * MessageSerializer: Converts between BaseMessage objects and wire format.
 * JsonSerializer: BaseMessage ↔ UTF-8 JSON string (human-readable)
 * BinarySerializer: BaseMessage ↔ MessagePack/Protobuf bytes (compact)
 * 
 * Used by BaseCommsAdapter to encode messages before transmission and
 * decode received bytes back to BaseMessage objects.
 */
export interface MessageSerializer {
  /**
   * Serialize BaseMessage to wire format.
   * JsonSerializer returns UTF-8 string, BinarySerializer returns Uint8Array.
   * Output passed to BaseCommsAdapter.sendRaw() for transmission.
   */
  serialize(message: BaseMessage): Uint8Array | string;

  /**
   * Deserialize wire format back to BaseMessage.
   * Input is raw data received from transport (serial port, socket, etc.).
   * Handles both string and binary inputs for flexibility.
   */
  deserialize(data: Uint8Array | string): BaseMessage;
}
